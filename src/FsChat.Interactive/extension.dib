#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"name":"csharp"},{"aliases":[],"languageName":"fsharp","name":"fsharp"},{"aliases":["js"],"languageName":"JavaScript","name":"javascript"}]}}

#!fsharp

open System
open System.Threading.Tasks
open Microsoft.DotNet.Interactive
open Microsoft.DotNet.Interactive.Commands
open Microsoft.DotNet.Interactive.Formatting

type Markdown(text:string) =
    member val text = text with get
    /// Formatter for ChatResponse what collapses the details tag
    static member formatter =
        Action<_,_>(fun (m:Markdown) (writer:TextWriter) ->
            $"<div class='markdown'><pre>\n{m.text}\n</pre></div>\n<script type='module'>window.markdownAll()</script>"
            |> writer.Write)

Formatter.Register<Markdown>(Markdown.formatter, "text/html")

do
    let jsBundle : string = FsChat.Interactive.BundleHelper.loadBundle()
    $"<script type='module'>{jsBundle}</script>".DisplayAs("text/html") |> ignore

module DomAppend =

    type AppendData(text:string, id:string) =
        inherit KernelCommand("javascript")
        member _.Text with get () = text
        member _.Id with get () = id

    let private jsKernel =
        let jsKernel = Kernel.Root.FindKernelByName("javascript")
        jsKernel.RegisterCommandType<AppendData>()
        jsKernel

(*
    let myKernel =
        let myKernel = Kernel.Root.FindKernelByName("fsharp")
        myKernel.RegisterCommandHandler<AppendData>(fun (command:AppendData) ->
            let js = $"document.getElementById('{command.Id}').innerHTML += `{command.Text}`"
            jsKernel.SendAsync(SubmitCode(js, "javascript")) |> ignore
            Task.CompletedTask)
*)

    let domAppend (id:string) (text:string) =
        jsKernel.SendAsync(AppendData(text, id)) |> ignore

    let domAppendAsync (id:string) (text:string) =
        jsKernel.SendAsync(AppendData(text, id)) :> Task


let domAppend = DomAppend.domAppend
let domAppendAsync = DomAppend.domAppendAsync

open FSharp.Control
open Gpt.Types
open Gpt.Api
open FsChat

module NotebookRenderer =

    let tagIdGenerator =
        let mutable tagId = DateTimeOffset.UtcNow.ToUnixTimeSeconds() - 1727989007L
        fun () -> tagId <- tagId + 1L; tagId

    let formatChunk = function
        | Role role -> sprintf "\nRole: %s\n" role
        | Preamble text
        | Chunk text -> text
        | Finished (reason, stats) -> "" // sprintf "\n\nFinished in %.2fs: %A, %d tokens\n" (float stats.durationMs/1000.0) reason stats.nTokens
        | Err err -> sprintf "\nError: %s\n" err

    let isComplete = function
        | Finished _
        | Err _ -> true
        | _ -> false


    let create () =
        let htmlTagId = $"gptresp{tagIdGenerator()}"
        let display = $"<div class='chat-response' id='{htmlTagId}'/>".DisplayAs("text/html")

        let mutable lastTask = Task.Delay(TimeSpan.FromMilliseconds 250.0)
        let fullText = Text.StringBuilder()
        let mutable pendingTexts = ResizeArray<string>()

        let appendIncremental (stdout:string) =
            if lastTask.IsCompleted then
                let stdout =
                    if pendingTexts.Count = 0 then stdout
                    else
                    pendingTexts.Add(stdout)
                    pendingTexts |> String.concat "" |> fun p -> p + stdout
                pendingTexts.Clear()
                lastTask <- domAppendAsync htmlTagId stdout
            else
                pendingTexts.Add(stdout)
                lastTask <- task {
                    do! lastTask
                    match pendingTexts.Count with
                    | 0 ->
                        return! Task.CompletedTask
                    | text ->
                        let text = pendingTexts |> String.concat ""
                        pendingTexts.Clear()
                        return! domAppendAsync htmlTagId text
                }

        let renderFinal () =
            task {
                do! lastTask
                display.Update(Markdown(fullText.ToString()))
            } |> ignore

        fun (chunk:GptChunk) ->
            let stdout = formatChunk chunk
            fullText.Append(stdout) |> ignore
            if isComplete chunk then
                renderFinal()
            else
                appendIncremental stdout


Chat.defaultRenderer <- NotebookRenderer.create

type ChatResponse with
    /// Formatter for ChatResponse what collapses the details tag
    static member formatter =
        Action<_,_>(fun (value:ChatResponse) (writer:TextWriter) ->
            {| text=value.text; result=value.result |} // repack it into anonymous record to avoid recursion
            |> _.ToDisplayString("text/html") // render as html
            |> _.Replace("details open=\"open\"", "details") // but collapse the details tag
            |> writer.Write)

Formatter.Register<ChatResponse>(ChatResponse.formatter, "text/html")

#!javascript

// register the AppendData command handler on javascript kernel
(function() {
    let jskernel = kernel.root.findKernelByName('javascript');

    jskernel.registerCommandHandler({commandType: 'AppendData', handle: c => {
        const cmd = c.commandEnvelope.command;
        window.appendChunk(cmd.id, cmd.text);
    }});
})();

#!fsharp

// test the domAppend function
(*
if false then
    "<h5>Appending text below:</h5><p id='out1'></p>".DisplayAs("text/html") |> ignore

    System.Threading.Tasks.Task.Delay(100).Wait()
    for s in ["# Hello";"\n\n"; "beautiful"; " "; "world";"!"] do
        domAppendAsync "out1" s |> (_.Wait()) |> ignore
*)
