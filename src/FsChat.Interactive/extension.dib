#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"name":"csharp"},{"aliases":[],"languageName":"fsharp","name":"fsharp"},{"aliases":["js"],"languageName":"JavaScript","name":"javascript"}]}}

#!fsharp

open System
open System.Threading.Tasks
open Microsoft.DotNet.Interactive
open Microsoft.DotNet.Interactive.Commands
open Microsoft.DotNet.Interactive.Formatting

type Markdown(text:string, ?htmlProps:string) =
    member val props = htmlProps |> Option.defaultValue ""
    member val text = text with get
    /// Formatter for ChatResponse what collapses the details tag
    static member formatter =
        Action<_,_>(fun (m:Markdown) (writer:TextWriter) ->
            $"<div class='markdown' {m.props}><pre>\n{m.text}\n</pre></div>\n<script type='module'>window.markdownAll()</script>"
            |> writer.Write)

Formatter.Register<Markdown>(Markdown.formatter, "text/html")

do
    let jsBundle : string = FsChat.Interactive.BundleHelper.loadBundle()
    $"<script type='module'>{jsBundle}</script>".DisplayAs("text/html") |> ignore

module JsKernel =

    let private jsKernel = Kernel.Root.FindKernelByName("javascript")

    type AppendMarkdown(tagId:string, text:string) =
        inherit KernelCommand("javascript")
        member _.Text with get () = text
        member _.TagId with get () = tagId
        member this.sendAsync() = jsKernel.SendAsync(this) :> Task

    type UpdateFullMarkdown(displayId:string, tagId:string, classes:string, props:string, text:string) =
        inherit KernelCommand("javascript")
        member _.Text with get () = text
        member _.DisplayId with get () = displayId
        member _.TagId with get () = tagId
        member _.Classes with get () = classes
        member _.Props with get () = props
        member this.sendAsync() = jsKernel.SendAsync(this) :> Task
(*
    type MarkdownResult(text:string) =
        inherit KernelCommand("fsharp")
        member _.Text with get () = text
        member this.sendAsync() = jsKernel.SendAsync(this) |> ignore
*)

    do
        jsKernel.RegisterCommandType<AppendMarkdown>()
        jsKernel.RegisterCommandType<UpdateFullMarkdown>()



(*
    do
        markdownCallback = fun (cmd:TCommand) (ctx:KernelInvocationContext) ->
            printfn "MarkdownHandler: %A" cmd
            Task.CompletedTask

        let myKernel = Kernel.Root.FindKernelByName("fsharp")
        myKernel.RegisterCommandHandler<MarkdownResult>(Func<_,_>(markdownCallback)
*)

(*
    let myKernel =
        let myKernel = Kernel.Root.FindKernelByName("fsharp")
        myKernel.RegisterCommandHandler<AppendData>(fun (command:AppendData) ->
            let js = $"document.getElementById('{command.Id}').innerHTML += `{command.Text}`"
            jsKernel.SendAsync(SubmitCode(js, "javascript")) |> ignore
            Task.CompletedTask)
*)


open FSharp.Control
open Gpt.Types
open Gpt.Api
open FsChat

type NotebookRenderer(?style: string) =

    let tagIdGenerator =
        let mutable tagId = DateTimeOffset.UtcNow.ToUnixTimeSeconds() - 1727989007L
        fun () -> tagId <- tagId + 1L; tagId

    let formatChunk = function
        | Role role -> sprintf "\nRole: %s\n" role
        | Preamble text
        | Chunk text -> text
        | Finished (reason, stats) -> "" // sprintf "\n\nFinished in %.2fs: %A, %d tokens\n" (float stats.durationMs/1000.0) reason stats.nTokens
        | Err err -> sprintf "\nError: %s\n" err

    let isComplete = function
        | Finished _
        | Err _ -> true
        | _ -> false

    interface IChatRenderer with
        member _.Create() =
            let htmlTagId = $"gptresp{tagIdGenerator()}"
            let props =
                match style with
                | None -> ""
                | Some style -> $"style='{style}'"
            let display = $"<div class='chat-response' id='{htmlTagId}' {props}/>".DisplayAs("text/html")

            let mutable lastTask = Task.Delay(TimeSpan.FromMilliseconds 250.0)
            let fullText = Text.StringBuilder()
            let mutable pendingTexts = ResizeArray<string>()

            let appendIncremental (stdout:string) =
                if lastTask.IsCompleted then
                    let stdout =
                        if pendingTexts.Count = 0 then stdout
                        else
                        pendingTexts.Add(stdout)
                        pendingTexts |> String.concat "" |> fun p -> p + stdout
                    pendingTexts.Clear()
                    lastTask <- JsKernel.AppendMarkdown(htmlTagId, stdout).sendAsync()
                else
                    pendingTexts.Add(stdout)
                    lastTask <- task {
                        do! lastTask
                        match pendingTexts.Count with
                        | 0 ->
                            return! Task.CompletedTask
                        | text ->
                            let text = pendingTexts |> String.concat ""
                            pendingTexts.Clear()
                            return! JsKernel.AppendMarkdown(htmlTagId, text).sendAsync()
                    }

            let renderFinal () =
                task {
                    do! lastTask
                    //display.Update(Markdown("Updated:"+fullText.ToString(), props))
                    do! JsKernel.UpdateFullMarkdown(display.DisplayId, htmlTagId, "", props, fullText.ToString()).sendAsync()
                    //do! JsKernel.UpdateFullMarkdown(htmlTagId, fullText.ToString()).sendAsync()
                } |> ignore

            fun (chunk:GptChunk) ->
                let stdout = formatChunk chunk
                fullText.Append(stdout) |> ignore
                if isComplete chunk then
                    renderFinal()
                else
                    appendIncremental stdout


Chat.defaultRenderer <- NotebookRenderer()

type ChatResponse with
    /// Formatter for ChatResponse what collapses the details tag
    static member formatter =
        Action<_,_>(fun (value:ChatResponse) (writer:TextWriter) ->
            {| text=value.text; result=value.result |} // repack it into anonymous record to avoid recursion
            |> _.ToDisplayString("text/html") // render as html
            |> _.Replace("details open=\"open\"", "details") // but collapse the details tag
            |> writer.Write)

Formatter.Register<ChatResponse>(ChatResponse.formatter, "text/html")

#!javascript

// register the AppendData command handler on javascript kernel
(function() {
    let jskernel = kernel.root.findKernelByName('javascript');

    jskernel.registerCommandHandler({commandType: 'AppendMarkdown', handle: c => {
        const cmd = c.commandEnvelope.command;
        window.appendMdChunk(cmd.tagId, cmd.text);
    }});

    let updateDisplayedValue = (valueId, htmlText) => {
        let fskernel = kernel.root.findKernelByName('fsharp');
        let displayedValue = {
            // KernelCommand  -- polytglot-notebooks/src/contracts.ts
            destinationUri: null,
            originUri: null,
            targetKernelName: fskernel.kernelInfo.localName,
            // UpdateDisplayedValue
            formattedValue: {
                mimeType: 'text/html',
                suppressDisplay: false,
                value: htmlText,
            },
            // id of value to be updated
            valueId: valueId,
        };
        let cmdEnvelope = { commandType:'UpdateDisplayedValue', command:displayedValue };
        fskernel.send(cmdEnvelope);
    }

    jskernel.registerCommandHandler({commandType: 'UpdateFullMarkdown', handle: async c => {
        let { displayId, tagId, classes, props, text } = c.commandEnvelope.command;
        let mdHtml = await window.renderMarkdown(text);
        mdHtml = mdHtml.replace(/<\/t(.)>\s+<t/g, '</t$1><t');
        let html = `<div class='chat-response markdown md-done ${classes}' id='${tagId}' ${props}>${mdHtml}</div>`;
        updateDisplayedValue(displayId, html);
        //updateDisplayedValue(displayId, text);
    }});
    console.log("test2");
})();
