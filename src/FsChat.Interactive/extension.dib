#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"name":"csharp"},{"aliases":[],"languageName":"fsharp","name":"fsharp"},{"aliases":["js"],"languageName":"JavaScript","name":"javascript"}]}}

#!fsharp

open System
open System.Threading.Tasks
open Microsoft.DotNet.Interactive
open Microsoft.DotNet.Interactive.Commands
open Microsoft.DotNet.Interactive.Formatting

do
    let jsBundle : string = FsChat.Interactive.BundleHelper.loadBundle()
    $"<script type='module'>{jsBundle}</script>".DisplayAs("text/html") |> ignore

module JsKernelProxy =

    let private jsKernel = Kernel.Root.FindKernelByName("javascript")

    type AppendMarkdown(tagId:string, text:string) =
        inherit KernelCommand("javascript")
        member _.Text with get () = text
        member _.TagId with get () = tagId
        member this.sendAsync() = jsKernel.SendAsync(this) :> Task

    type UpdateFullMarkdown(displayId:string, props:string, css:string, text:string) =
        inherit KernelCommand("javascript")
        member _.Text with get () = text
        member _.DisplayId with get () = displayId
        member _.Css with get () = css
        member _.Props with get () = props
        member this.sendAsync() = jsKernel.SendAsync(this) :> Task
(*
    type MarkdownResult(text:string) =
        inherit KernelCommand("fsharp")
        member _.Text with get () = text
        member this.sendAsync() = jsKernel.SendAsync(this) |> ignore
*)

    do
        jsKernel.RegisterCommandType<AppendMarkdown>()
        jsKernel.RegisterCommandType<UpdateFullMarkdown>()



(*
    do
        markdownCallback = fun (cmd:TCommand) (ctx:KernelInvocationContext) ->
            printfn "MarkdownHandler: %A" cmd
            Task.CompletedTask

        let myKernel = Kernel.Root.FindKernelByName("fsharp")
        myKernel.RegisterCommandHandler<MarkdownResult>(Func<_,_>(markdownCallback)
*)

(*
    let myKernel =
        let myKernel = Kernel.Root.FindKernelByName("fsharp")
        myKernel.RegisterCommandHandler<AppendData>(fun (command:AppendData) ->
            let js = $"document.getElementById('{command.Id}').innerHTML += `{command.Text}`"
            jsKernel.SendAsync(SubmitCode(js, "javascript")) |> ignore
            Task.CompletedTask)
*)

[<AutoOpen>]
module NotebookRenderer =

    open FSharp.Control
    open FsChat.Types
    //open FsChat.AiApi
    open FsChat.Chat

    /// A renderer that formats chat response into html and renders it into a notebook cell
    /// props: additional html properties to add to target div element, e.g. `"id='myid' class='myclass otherclass'"`
    /// css: additional css text, e.g. `"<style>th{color:blue}</style>"` to add before rendered html
    type NotebookRenderer(?props: string, ?css:string) =

        let props = defaultArg props ""
        let css = defaultArg css ""

        let tagIdGenerator =
            let mutable tagId = DateTimeOffset.UtcNow.ToUnixTimeSeconds() - 1727989007L
            fun () -> tagId <- tagId + 1L; tagId

        let formatChunk = function
            | Role role -> sprintf "\nRole: %s\n" role
            | Preamble text
            | Chunk text -> text
            | Finished (reason, stats) -> "" // sprintf "\n\nFinished in %.2fs: %A, %d tokens\n" (float stats.durationMs/1000.0) reason stats.nTokens
            | Err err -> sprintf "\nError: %s\n" err

        let isComplete = function
            | Finished _
            | Err _ -> true
            | _ -> false

        interface IChatRenderer with
            member _.Create() =
                let htmlTagId = $"gptresp{tagIdGenerator()}"
                let display = $"<div class='chat-response' id='{htmlTagId}' {props}/>".DisplayAs("text/html")

                let mutable lastTask = Task.Delay(TimeSpan.FromMilliseconds 250.0)
                let fullText = Text.StringBuilder()
                let mutable pendingTexts = ResizeArray<string>()

                let appendIncremental (stdout:string) =
                    if lastTask.IsCompleted then
                        let stdout =
                            if pendingTexts.Count = 0 then stdout
                            else
                            pendingTexts.Add(stdout)
                            pendingTexts |> String.concat "" |> fun p -> p + stdout
                        pendingTexts.Clear()
                        lastTask <- JsKernelProxy.AppendMarkdown(htmlTagId, stdout).sendAsync()
                    else
                        pendingTexts.Add(stdout)
                        lastTask <- task {
                            do! lastTask
                            match pendingTexts.Count with
                            | 0 ->
                                return! Task.CompletedTask
                            | text ->
                                let text = pendingTexts |> String.concat ""
                                pendingTexts.Clear()
                                return! JsKernelProxy.AppendMarkdown(htmlTagId, text).sendAsync()
                        }

                let renderFinal () =
                    task {
                        do! lastTask
                        do! JsKernelProxy.UpdateFullMarkdown(display.DisplayId, props, css, fullText.ToString()).sendAsync()
                    } |> ignore

                fun (chunk:GptChunk) ->
                    let stdout = formatChunk chunk
                    fullText.Append(stdout) |> ignore
                    if isComplete chunk then
                        renderFinal()
                    else
                        appendIncremental stdout


    /// Formatter for ChatResponse what collapses the details tag
    let chatResponseFormatter =
        Action<_,_>(fun (value:ChatResponse) (writer:TextWriter) ->
            {| text=value.text; result=value.result |} // repack it into anonymous record to avoid recursion
            |> _.ToDisplayString("text/html") // render as html
            |> _.Replace("details open=\"open\"", "details") // but collapse the details tag
            |> writer.Write)

    do
        Chat.defaultRenderer <- NotebookRenderer()
        Formatter.Register<ChatResponse>(chatResponseFormatter, "text/html")

#!javascript

// register the AppendData command handler on javascript kernel
(function() {
    let jskernel = kernel.root.findKernelByName('javascript');

    jskernel.registerCommandHandler({commandType: 'AppendMarkdown', handle: c => {
        const cmd = c.commandEnvelope.command;
        window.appendMdChunk(cmd.tagId, cmd.text);
    }});

    let updateDisplayedValue = (valueId, htmlText) => {
        let fskernel = kernel.root.findKernelByName('fsharp');
        let displayedValue = {
            // KernelCommand  -- polytglot-notebooks/src/contracts.ts
            destinationUri: null,
            originUri: null,
            targetKernelName: fskernel.kernelInfo.localName,
            // UpdateDisplayedValue
            formattedValue: {
                mimeType: 'text/html',
                suppressDisplay: false,
                value: htmlText,
            },
            // id of value to be updated
            valueId: valueId,
        };
        let cmdEnvelope = { commandType:'UpdateDisplayedValue', command:displayedValue };
        fskernel.send(cmdEnvelope);
    }

    jskernel.registerCommandHandler({commandType: 'UpdateFullMarkdown', handle: async c => {
        let { displayId, classes, props, css, text } = c.commandEnvelope.command;
        let mdHtml = await window.renderMarkdown(text);
        // remove some spacing to render table rows in one line
        mdHtml = mdHtml.replace(/<\/t(.)>\s+<t/g, '</t$1><t');
        let html = `<div class='chat-response md-blk'>${css}<div ${props}>${mdHtml}</div></div>`;
        updateDisplayedValue(displayId, html);
        //updateDisplayedValue(displayId, text);
    }});
    console.log("FsChat is ready.");
})();
